# DP에 대한 고찰 (Dynamic Programming)

## 1. DP란 무엇인가
DP는 **같은 계산을 반복하지 않기 위해**
> "문제를 더 작은 문제로 나누고, 그 결과를 저장해 재사용하는 사고 방식"

이다.

중요한 점은 **알고리즘이 아니라 사고 구조**라는 것이다.

---

## 2. DP 문제를 보는 관점

### ❌ 잘못된 접근
- 공식을 외우려 한다
- 유형을 먼저 외우고 문제를 끼워 맞춘다
- 코드부터 작성한다

### ⭕ 올바른 접근
1. 이 문제가 **중복 계산**을 하고 있는가?
2. 작은 문제의 해답으로 큰 문제를 만들 수 있는가?
3. 그 “작은 문제”를 **상태(state)** 로 정의할 수 있는가?

이 3개가 YES면 DP다.

---

## 3. DP의 핵심 구성요소 4가지

### ① 상태 정의 (State)
> dp[i]가 무엇을 의미하는가?

- dp[i]는 반드시 **한 문장으로 설명 가능**해야 한다
- 예:
    - dp[i] = i번째 원소까지 고려했을 때의 최댓값
    - dp[i][j] = i번째까지 봤고, j 상태일 때의 최적해

👉 상태 정의가 곧 문제의 절반이다.

---

### ② 점화식 (Transition)
> dp[i]를 dp[?]로 어떻게 만들 것인가?

- 현재 상태를 만들기 위해 **이전 어떤 상태를 참조하는가**
- 대부분의 DP는 아래 중 하나다
    - dp[i] = dp[i-1] + ?
    - dp[i] = max(dp[i-1], dp[i-2] + ?)
    - dp[i][j] = min/max(dp[i-1][?] + ?)

👉 점화식은 “선택”의 결과다.

---

### ③ 초기값 (Base Case)
> 가장 작은 문제는 무엇인가?

- dp[0], dp[1]이 반드시 정의돼야 한다
- 초기값이 틀리면 **전체가 다 맞아도 오답**

👉 DP 버그의 절반은 초기값이다.

---

### ④ 계산 순서 (Order)
> 어떤 순서로 dp를 채워야 하는가?

- 점화식에서 참조하는 값이
    - 이미 계산돼 있어야 한다
- 그래서:
    - 1차원 → 보통 앞에서 뒤
    - 2차원 → 행/열 중 하나 고정

👉 순서가 곧 시간복잡도다.

---

## 4. DP 문제의 본질적 패턴

### DP는 결국 이 질문이다
> “지금 이 선택을 했을 때, 미래의 최적해는 어떻게 되는가?”

그래서 DP 문제는 항상:
- 선택 / 비선택
- 포함 / 제외
- 이전 상태 유지 / 변경

중 하나로 귀결된다.

---

## 5. 자주 겪는 실수들

### ❌ 상태를 너무 크게 잡음
- dp에 필요 없는 정보까지 넣는다
- → 메모리 초과 / 시간 초과

### ❌ 상태 의미가 모호함
- dp[i]가 뭘 의미하는지 말로 설명 못함
- → 점화식이 흔들림

### ❌ 그리디처럼 생각함
- “지금 최선”이 전체 최선이라고 착각
- → 반례에 바로 터짐

---

## 6. DP와 다른 알고리즘의 경계

### DP vs Greedy
- Greedy: 지금 선택이 항상 최적임을 증명 가능
- DP: 지금 선택이 최적임을 **보장할 수 없음**

👉 Greedy가 안 되면 DP를 의심한다.

---

### DP vs 완전탐색
- 완전탐색: 모든 경우를 직접 본다
- DP: 중복되는 경우를 저장해서 줄인다

👉 DP는 “가지치기된 완전탐색”이다.

---

## 7. DP 문제를 만났을 때 체크리스트

- [ ] 중복 계산이 있는가?
- [ ] 상태를 한 문장으로 정의할 수 있는가?
- [ ] 점화식이 이전 상태만 참조하는가?
- [ ] 초기값이 명확한가?
- [ ] 계산 순서가 논리적으로 맞는가?

이 5개가 다 맞으면 **코드는 따라온다**.

---

## 8. 한 줄 요약
> DP는 공식을 외우는 게 아니라  
> **“상태를 정의하는 능력”을 기르는 알고리즘이다.**