# 칸토어 재귀 구현을 통해 느낀 아쉬운 점과 핵심 사고 정리

## 1. 아쉬웠던 지점 정리

### 1️⃣ String 불변성에 대한 대응 사고가 즉각적으로 나오지 않았다
- 처음에는 String으로 처리하려고 접근함
- String은 immutable이라 특정 idx만 수정이 불가능
- 문제를 풀면서:
    - "아, 이건 구조적으로 안 되는구나"
    - → idx 접근이 가능한 char[]로 전환해야 함을 깨달음

👉 **교훈**
- 출력용 자료구조와 작업용 자료구조는 다를 수 있음
- “재귀 구현이 가능한 상태 표현인가?”를 먼저 점검해야 함


### 2️⃣ 재귀에서 ‘더하려는 사고’가 먼저 떠올랐다
- 처음에는:
    - 왼쪽 + 가운데 + 오른쪽을 더해야 하나?
    - 문자열을 합치는 구조를 떠올림
- 구현을 진행하면서:
    - 이 문제는 누적/반환 재귀가 아니라
    - **상태를 직접 수정하는 분할 재귀**라는 점을 인식함

👉 **교훈**
- 재귀는 항상 “결과를 return 해야 한다”는 고정관념을 버릴 것
- void 재귀도 충분히 강력한 도구


### 3️⃣ 3등분은 떠올랐지만, ‘어디서부터 나누는지’에서 막혔다
- len / 3으로 나눈다는 개념은 있었음
- 하지만:
    - start 기준인지
    - idx 기준인지
    - 어떤 범위를 재귀 대상으로 삼는지 헷갈림

결국:
- “재귀의 대상을 길이로 줄이자”는 결론에 도달

👉 **교훈**
- 재귀는 인덱스보다 **구간 모델링**이 먼저다
- start + len 구조를 명확히 잡아야 구현이 단순해진다


## 2. 핵심 사고 전환 포인트 (중요)

### 🔑 사고 기점 1: 재귀는 ‘무엇을 더할지’가 아니라 ‘무엇을 줄일지’
- 잘못된 질문: 이걸 어떻게 합치지?
- 올바른 질문: 이 문제의 크기는 호출마다 어떻게 줄어드는가?

칸토어에서:
- 줄어드는 것: len
- 줄어들지 않는 것: 규칙


### 🔑 사고 기점 2: 재귀 함수의 책임을 한 문장으로 고정
```text
recursion(start, len)는
[start, start+len) 구간을 칸토어 규칙에 맞게 완성한다
```
- return 값에 집착하지 않게 됨  
- 내부 구현을 신뢰하고 호출할 수 있게 됨  

### 🔑 사고 기점 3: 가운데는 ‘재귀 대상’이 아니다

가운데 구간은:

- 제거(처리) 대상이지  
- 동일한 문제 형태가 아님  

👉 재귀는 문제 형태가 유지되는 부분에만 적용한다  

---

## 3. 구현 관점에서 얻은 정리

### ✔️ 좋은 선택

- char[] 사용  
- start + len 기반 재귀  
- len == 1을 base case로 설정  
- 상태를 직접 수정하는 void 재귀  

### ⚠️ 다음에 더 빠르게 하기 위한 체크

재귀 함수 설계 전에 반드시 확인:

- 이 함수가 책임지는 단위는 무엇인가?  
- 그 단위는 호출마다 줄어드는가?  
- 줄어든 단위에도 같은 책임을 맡길 수 있는가?  

---

## 4. 이번 문제에서 얻은 가장 중요한 교훈

재귀는 구현 기법이 아니라  
문제를 같은 형태로 줄여나가는 사고 방식이다.

막혔던 이유는 재귀를 못해서가 아니라  

문제를 바라보는 단위가 아직 고정되지 않았기 때문  

그 단위를 ‘길이’로 전환한 순간 전체 구조가 보였다  

---

## 5. 다음 재귀 문제를 풀 때 기억할 문장

- “이 재귀 함수는 무엇 하나를 책임지는가?”  
- “이 문제의 크기는 무엇이며, 어떻게 줄어드는가?”  
- “이 부분은 재귀 대상인가, 단순 처리인가?”

